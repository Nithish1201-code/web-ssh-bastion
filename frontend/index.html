<!DOCTYPE html>
<html lang="en">
  <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Web SSH Bastion</title>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
          href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
          rel="stylesheet"
        />
        <link
          rel="stylesheet"
          href="/vendor/xterm.css"
          onerror="this.onerror=null;this.href='https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css'"
        />
        <link
          rel="stylesheet"
          href="/vendor/gridstack.min.css"
          onerror="this.onerror=null;this.href='https://cdn.jsdelivr.net/npm/gridstack@10.3.1/dist/gridstack.min.css'"
        />
        <style>
          :root {
            color-scheme: dark;
            --bg: #000000;
            --panel: #050505;
            --panel-2: #0a0a0a;
            --panel-3: #101010;
            --border: #1a1a1a;
            --text: #f5f5f7;
            --muted: #9ca3af;
            --accent: #64d2ff;
            --accent-2: #a78bfa;
            --success: #34d399;
            --warning: #fbbf24;
            --danger: #f87171;
            --glass: rgba(15, 15, 15, 0.65);
            --glow: 0 0 0 1px rgba(100, 210, 255, 0.2), 0 10px 30px rgba(0, 0, 0, 0.35);
          }

          * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
          }

          body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'SF Pro Text', system-ui, sans-serif;
            background: radial-gradient(circle at 20% 20%, #0c0c0c 0%, #000 35%, #000 100%);
            color: var(--text);
            letter-spacing: 0.01em;
          }

          .app {
            display: grid;
            grid-template-columns: 320px 1fr;
            min-height: 100vh;
          }

          .sidebar {
            background: linear-gradient(180deg, rgba(10, 10, 10, 0.98), rgba(5, 5, 5, 0.98));
            border-right: 1px solid var(--border);
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            box-shadow: inset -1px 0 0 rgba(255, 255, 255, 0.02);
          }

          .brand {
            display: flex;
            flex-direction: column;
            gap: 6px;
          }

          .brand h1 {
            font-size: 20px;
            font-weight: 600;
          }

          .brand span {
            font-size: 12px;
            color: var(--muted);
          }

          .status-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 999px;
            background: rgba(100, 210, 255, 0.16);
            color: var(--accent);
            font-size: 12px;
            border: 1px solid rgba(100, 210, 255, 0.25);
          }

          .filters {
            display: flex;
            flex-direction: column;
            gap: 12px;
          }

          .filters input {
            width: 100%;
            padding: 11px 12px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: #070707;
            color: var(--text);
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.03);
          }

          .filter-row {
            display: flex;
            gap: 8px;
          }

          .chip {
            padding: 6px 12px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: #0b0b0b;
            font-size: 12px;
            color: var(--muted);
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
          }

          .chip.active {
            border-color: var(--accent);
            color: var(--accent);
          }

          .target-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
          }

          .target-card {
            background: #0b0b0b;
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            box-shadow: var(--glow);
          }

          .target-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
          }

          .target-name {
            font-weight: 600;
            font-size: 14px;
          }

          .target-meta {
            font-size: 12px;
            color: var(--muted);
          }

          .badge {
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
          }

          .badge.running {
            background: rgba(34, 197, 94, 0.16);
            color: var(--success);
          }

          .badge.stopped {
            background: rgba(245, 158, 11, 0.2);
            color: var(--warning);
          }

          .badge.unknown {
            background: rgba(148, 163, 184, 0.2);
            color: var(--muted);
          }

          .target-actions {
            display: flex;
            gap: 8px;
          }

          .btn {
            padding: 8px 12px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: #0e0e0e;
            color: var(--text);
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
          }

          .btn.primary {
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            border: none;
            color: #030303;
            font-weight: 600;
          }

          .icon {
            width: 14px;
            height: 14px;
            display: inline-block;
          }

          .icon svg {
            width: 100%;
            height: 100%;
            fill: currentColor;
          }

          .btn:hover {
            transform: translateY(-1px);
          }

          .workspace {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
          }

          .topbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 18px 26px;
            border-bottom: 1px solid var(--border);
            background: var(--glass);
            backdrop-filter: blur(16px);
          }

          .topbar .left {
            display: flex;
            flex-direction: column;
            gap: 6px;
          }

          .topbar h2 {
            font-size: 18px;
            font-weight: 600;
          }

          .topbar span {
            font-size: 12px;
            color: var(--muted);
          }

          .topbar-actions {
            display: flex;
            gap: 10px;
          }

          .session-bar {
            display: flex;
            gap: 8px;
            padding: 12px 18px;
            border-bottom: 1px solid var(--border);
            overflow-x: auto;
            background: #0a0a0a;
          }

          .session-tab {
            border: 1px solid transparent;
            background: #0f0f0f;
            color: var(--muted);
            padding: 8px 12px;
            border-radius: 12px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
          }

          .session-tab.active {
            border-color: var(--accent);
            color: var(--text);
          }

          .session-tab .close {
            font-weight: 700;
            opacity: 0.6;
          }

          .grid-stack {
            background: var(--bg);
            padding: 16px;
            flex: 1;
          }

          .grid-stack-item-content {
            background: #080808;
            border: 1px solid var(--border);
            border-radius: 16px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100%;
            box-shadow: var(--glow);
          }

          .tile-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 14px;
            background: rgba(10, 10, 10, 0.9);
            border-bottom: 1px solid var(--border);
            cursor: grab;
          }

          .tile-header:active {
            cursor: grabbing;
          }

          .traffic-lights {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-right: 8px;
          }

          .traffic-lights span {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
          }

          .traffic-lights .close {
            background: #ff5f57;
          }

          .traffic-lights .min {
            background: #febc2e;
          }

          .traffic-lights .max {
            background: #28c840;
          }

          .tile-header h4 {
            font-size: 13px;
            font-weight: 600;
          }

          .tile-header span {
            font-size: 11px;
            color: var(--muted);
          }

          .tile-actions {
            display: flex;
            gap: 8px;
          }

          .tile-actions button {
            background: transparent;
            color: var(--muted);
            border: none;
            cursor: pointer;
            font-size: 14px;
            padding: 4px;
            border-radius: 8px;
          }

          .tile-actions button:hover {
            color: var(--text);
          }

          .terminal-surface {
            flex: 1;
            padding: 10px;
            background: #000;
          }

          .terminal-surface .xterm,
          .terminal-surface .xterm-viewport,
          .terminal-surface .xterm-screen {
            height: 100%;
          }

          .tile-active .grid-stack-item-content {
            border-color: var(--accent);
            box-shadow: 0 0 0 1px rgba(100, 210, 255, 0.35), 0 12px 32px rgba(0, 0, 0, 0.45);
          }

          .empty-state {
            padding: 28px;
            color: var(--muted);
            font-size: 14px;
            text-align: center;
          }

          .toast {
            position: fixed;
            right: 24px;
            bottom: 24px;
            padding: 12px 16px;
            border-radius: 12px;
            background: #0c0c0c;
            border: 1px solid var(--border);
            color: var(--text);
            font-size: 12px;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.2s ease;
          }

          .toast.show {
            opacity: 1;
            transform: translateY(0);
          }

          .btn[disabled] {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
          }

          .debug-panel {
            position: fixed;
            right: 24px;
            bottom: 24px;
            width: 360px;
            max-width: calc(100vw - 48px);
            max-height: 320px;
            background: #0b0b0b;
            border: 1px solid var(--border);
            border-radius: 14px;
            box-shadow: var(--glow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transform: translateY(16px);
            opacity: 0;
            pointer-events: none;
            transition: all 0.2s ease;
          }

          .debug-panel.show {
            transform: translateY(0);
            opacity: 1;
            pointer-events: auto;
          }

          .debug-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            border-bottom: 1px solid var(--border);
            background: #0f0f0f;
          }

          .debug-header h4 {
            font-size: 12px;
            font-weight: 600;
          }

          .debug-actions {
            display: flex;
            gap: 8px;
          }

          .debug-log {
            padding: 10px 12px;
            font-size: 11px;
            color: var(--muted);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
          }

          .debug-entry {
            padding: 8px;
            border-radius: 10px;
            background: #0a0a0a;
            border: 1px solid rgba(255, 255, 255, 0.05);
          }

          .debug-entry strong {
            color: var(--text);
            font-weight: 600;
          }

          @media (max-width: 1100px) {
            .app {
              grid-template-columns: 1fr;
            }
            .sidebar {
              border-right: none;
              border-bottom: 1px solid var(--border);
            }
          }
        </style>
      </head>
      <body>
        <div class="app">
          <aside class="sidebar">
            <div class="brand">
              <h1>Web SSH Bastion</h1>
              <span>Multi-session control plane</span>
            </div>
            <div class="status-pill" id="modePill">Loading...</div>

            <div class="filters">
              <input id="searchInput" placeholder="Search VM/CT by name or IP" />
              <div class="filter-row">
                <div class="chip active" data-filter="all">All</div>
                <div class="chip" data-filter="ct">CT</div>
                <div class="chip" data-filter="vm">VM</div>
              </div>
            </div>

            <div class="target-list" id="targetList"></div>
          </aside>

          <main class="workspace">
            <div class="topbar">
              <div class="left">
                <h2>Terminal Workspace</h2>
                <span id="summaryText">Loading targets...</span>
                <span id="buildText">Build: 69420</span>
              </div>
              <div class="topbar-actions">
                <button class="btn" id="refreshBtn">
                  <span class="icon" aria-hidden="true">
                    <svg viewBox="0 0 24 24">
                      <path
                        d="M12 5a7 7 0 0 1 6.54 4.5h-2.1a5 5 0 1 0 0 5h2.1A7 7 0 1 1 12 5Zm7 0V2l3 3-3 3V5Z"
                      />
                    </svg>
                  </span>
                  Refresh Targets
                </button>
                <button class="btn primary" id="newSessionBtn">
                  <span class="icon" aria-hidden="true">
                    <svg viewBox="0 0 24 24">
                      <path d="M11 5h2v14h-2zM5 11h14v2H5z" />
                    </svg>
                  </span>
                  New Terminal
                </button>
                <button class="btn" id="debugToggleBtn">
                  <span class="icon" aria-hidden="true">
                    <svg viewBox="0 0 24 24">
                      <path d="M11 2h2v3h-2zM4 11h3v2H4zM17 11h3v2h-3zM6.2 6.2l1.4-1.4 2.1 2.1-1.4 1.4zM14.3 14.3l1.4-1.4 2.1 2.1-1.4 1.4zM12 7a5 5 0 1 0 0 10 5 5 0 0 0 0-10z" />
                    </svg>
                  </span>
                  Debug
                </button>
              </div>
            </div>

            <div class="session-bar" id="sessionBar"></div>

            <div class="grid-stack" id="grid">
              <div class="empty-state" id="emptyState">
                Select a target to launch terminals. Drag and resize tiles freely.
              </div>
            </div>
          </main>
        </div>

        <div class="toast" id="toast"></div>
        <div class="debug-panel" id="debugPanel">
          <div class="debug-header">
            <h4>Debug Console</h4>
            <div class="debug-actions">
              <button class="btn" id="debugClearBtn">Clear</button>
              <button class="btn" id="debugCloseBtn">Close</button>
            </div>
          </div>
          <div class="debug-log" id="debugLog"></div>
        </div>

        <script src="/vendor/gridstack-all.js" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/npm/gridstack@10.3.1/dist/gridstack-all.js'"></script>
        <script src="/vendor/xterm.js" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js'"></script>
        <script src="/vendor/xterm-addon-fit.js" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js'"></script>
        <script>
          class TerminalApp {
            constructor() {
              this.targets = [];
              this.terminals = new Map();
              this.activeSessionId = null;
              this.filterType = 'all';
              this.authByTarget = new Map();
              this.debugOpen = false;
              this.wsUrl = this.getWsUrl();
              this.grid = this.createGrid();

              this.bindUI();
              this.init();
            }

            createGrid() {
              try {
                if (!window.GridStack) {
                  throw new Error('GridStack not available');
                }
                return GridStack.init(
                  {
                    margin: 10,
                    float: true,
                    cellHeight: 180,
                    draggable: { handle: '.tile-header', cancel: '.tile-actions button, .traffic-lights, .traffic-lights span' },
                    resizable: { handles: 'all' },
                  },
                  '#grid'
                );
              } catch (error) {
                console.error('Grid init failed:', error);
                const gridEl = document.getElementById('grid');
                return {
                  on: () => {},
                  addWidget: (el) => {
                    gridEl?.appendChild(el);
                    return el;
                  },
                  removeWidget: (el) => {
                    el?.remove();
                  },
                };
              }
            }

            getWsUrl() {
              const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
              return `${protocol}://${window.location.host}`;
            }

            bindUI() {
              document.getElementById('refreshBtn')?.addEventListener('click', () => this.reload());
              document.getElementById('newSessionBtn')?.addEventListener('click', () => {
                if (this.targets.length) {
                  this.openTerminal(this.targets[0]);
                } else {
                  this.toast('No targets available.');
                }
              });

              document.getElementById('debugToggleBtn')?.addEventListener('click', () => this.toggleDebug());
              document.getElementById('debugCloseBtn')?.addEventListener('click', () => this.setDebug(false));
              document.getElementById('debugClearBtn')?.addEventListener('click', () => this.clearDebug());

              document.getElementById('searchInput')?.addEventListener('input', () => this.renderTargets());

              document.querySelectorAll('.chip').forEach((chip) => {
                chip.addEventListener('click', () => {
                  document.querySelectorAll('.chip').forEach((c) => c.classList.remove('active'));
                  chip.classList.add('active');
                  this.filterType = chip.dataset.filter;
                  this.renderTargets();
                });
              });

              this.grid?.on?.('resizestop', (event, el) => {
                const sessionId = el?.dataset?.sessionId;
                if (sessionId) {
                  const data = this.terminals.get(sessionId);
                  data?.fitAddon?.fit();
                  if (data?.ws?.readyState === WebSocket.OPEN) {
                    data.ws.send(
                      JSON.stringify({
                        type: 'resize',
                        sessionId,
                        cols: data.term.cols,
                        rows: data.term.rows,
                      })
                    );
                  }
                }
              });
            }

            setDebug(open) {
              this.debugOpen = open;
              const panel = document.getElementById('debugPanel');
              panel.classList.toggle('show', open);
            }

            toggleDebug() {
              this.setDebug(!this.debugOpen);
            }

            clearDebug() {
              const log = document.getElementById('debugLog');
              log.innerHTML = '';
            }

            logDebug(message, data = {}) {
              const log = document.getElementById('debugLog');
              const entry = document.createElement('div');
              entry.className = 'debug-entry';
              const time = new Date().toLocaleTimeString();
              const payload = Object.keys(data).length ? `\n${JSON.stringify(data, null, 2)}` : '';
              entry.innerHTML = `<strong>${time}</strong> ${message}<pre style="white-space: pre-wrap; margin-top: 6px; color: #9ca3af;">${payload}</pre>`;
              log.prepend(entry);
              if (this.debugOpen) {
                log.scrollTop = 0;
              }
            }

            async init() {
              await this.loadTargets();
              await this.loadBuildInfo();
              this.renderTargets();
              this.updateSummary();
            }

            async reload() {
              await this.loadTargets();
              this.renderTargets();
              this.updateSummary();
            }

            async loadTargets() {
              try {
                const response = await fetch('/api/targets');
                const data = await response.json();
                this.targets = data.targets || [];
                this.mode = data.mode || 'unknown';
                const running = this.targets.filter((t) => t.status === 'running').length;
                document.getElementById('modePill').textContent = `${this.mode} mode · ${running}/${this.targets.length} running`;
              } catch (err) {
                console.error('Failed to load targets:', err);
                this.toast('Failed to load targets.');
              }
            }

            async loadBuildInfo() {
              try {
                const response = await fetch('/api/build');
                const data = await response.json();
                const build = data.build || 'unknown';
                document.getElementById('buildText').textContent = `Build: ${build}`;
              } catch (error) {
                document.getElementById('buildText').textContent = 'Build: unknown';
              }
            }

            updateSummary() {
              const text = this.targets.length
                ? `${this.targets.length} targets · ${this.terminals.size} active terminals`
                : 'No targets discovered yet';
              document.getElementById('summaryText').textContent = text;
            }

            renderTargets() {
              const list = document.getElementById('targetList');
              const query = document.getElementById('searchInput').value.toLowerCase();

              const filtered = this.targets.filter((target) => {
                const name = (target.name ?? '').toString();
                const ip = (target.ip ?? target.host ?? '').toString();
                const vmid = (target.vmid ?? '').toString();
                const matchesQuery =
                  name.toLowerCase().includes(query) ||
                  ip.toLowerCase().includes(query) ||
                  vmid.toLowerCase().includes(query);
                const type = (target.type ?? 'unknown').toString();
                const matchesType = this.filterType === 'all' || type === this.filterType;
                return matchesQuery && matchesType;
              });

              if (!filtered.length) {
                list.innerHTML = '<div class="empty-state">No matching targets.</div>';
                return;
              }

              list.innerHTML = filtered
                .map(
                  (target) => {
                    const type = (target.type ?? 'unknown').toString();
                    const status = (target.status ?? 'unknown').toString();
                    const name = (target.name ?? 'Unknown').toString();
                    const node = (target.node ?? 'node').toString();
                    const vmid = (target.vmid ?? '—').toString();
                    const ip = (target.ip ?? 'No IP').toString();
                    const os = (target.os ?? 'Unknown OS').toString();
                    const username = (target.username ?? 'unknown').toString();
                    return `
                  <div class="target-card">
                    <div class="target-header">
                      <div>
                        <div class="target-name">${name}</div>
                        <div class="target-meta">${type.toUpperCase()} · ${node} · ${vmid}</div>
                      </div>
                      <span class="badge ${status}">${status}</span>
                    </div>
                    <div class="target-meta">${ip} · ${os} · ${username}</div>
                    <div class="target-actions">
                      <button class="btn" data-action="open" data-id="${target.id}" ${target.status !== 'running' ? 'disabled' : ''}>Open Terminal</button>
                      <button class="btn" data-action="open-split" data-id="${target.id}" ${target.status !== 'running' ? 'disabled' : ''}>Open Split</button>
                    </div>
                  </div>
                `;
                  }
                )
                .join('');

              list.querySelectorAll('button[data-action]').forEach((button) => {
                button.addEventListener('click', () => {
                  if (button.disabled) {
                    this.toast('Target is offline.');
                    return;
                  }
                  const target = this.targets.find((t) => t.id === button.dataset.id);
                  if (!target) return;
                  const isSplit = button.dataset.action === 'open-split';
                  this.openTerminal(target, isSplit ? { w: 3, h: 4 } : undefined);
                });
              });
            }

            openTerminal(target, layout, retryState = {}) {
              if (!window.Terminal || !window.FitAddon?.FitAddon) {
                this.toast('Terminal engine failed to load. Check network or CDN.');
                this.logDebug('Terminal engine missing', {
                  terminal: !!window.Terminal,
                  fitAddon: !!window.FitAddon?.FitAddon,
                });
                return;
              }
              if (target.status !== 'running') {
                this.toast('Target is offline.');
                return;
              }
              if (!target.host) {
                this.toast('Target has no reachable host/IP.');
                return;
              }

              const authState = this.authByTarget.get(target.id) || {
                password: null,
                hostKeyAccepted: false,
              };

              if (retryState.forcePasswordPrompt || (!authState.password && authState.hostKeyAccepted)) {
                const password = window.prompt(`Enter SSH password for ${target.name}`);
                if (!password) {
                  this.toast('Password required to open terminal.');
                  return;
                }
                authState.password = password;
                retryState.forcePasswordPrompt = false;
              }

              const sessionId = `session-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
              const ws = new WebSocket(this.wsUrl);

              ws.onopen = () => {
                this.logDebug('WebSocket open', { sessionId, targetId: target.id });
                ws.send(
                  JSON.stringify({
                    type: 'open',
                    targetId: target.id,
                    sessionId,
                    cols: 80,
                    rows: 24,
                    password: authState.password,
                    acceptHostKey: authState.hostKeyAccepted,
                  })
                );
              };

              ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                const session = this.terminals.get(sessionId);

                if (!session) return;

                if (msg.type === 'ready') {
                  this.logDebug('Terminal ready', { sessionId });
                  this.focusSession(sessionId);
                } else if (msg.type === 'output') {
                  session.term.write(msg.data);
                } else if (msg.type === 'close') {
                  this.logDebug('Terminal closed', { sessionId });
                  this.closeTerminal(sessionId);
                } else if (msg.type === 'error') {
                  this.logDebug('Terminal error', { sessionId, error: msg.error, code: msg.code, fingerprint: msg.fingerprint });
                  if (msg.code === 'HOSTKEY') {
                    const confirm = window.prompt(
                      `Host key fingerprint for ${target.name}: ${msg.fingerprint}\nType YES to trust and continue`
                    );
                    if (confirm && confirm.toLowerCase() === 'yes') {
                      authState.hostKeyAccepted = true;
                      this.authByTarget.set(target.id, authState);
                      this.closeTerminal(sessionId);
                      this.openTerminal(target, layout, { forcePasswordPrompt: !authState.password });
                      return;
                    }
                    this.toast('Host key not accepted.');
                    this.closeTerminal(sessionId);
                    return;
                  }

                  if (msg.code === 'NO_AUTH') {
                    this.closeTerminal(sessionId);
                    this.openTerminal(target, layout, { forcePasswordPrompt: true });
                    return;
                  }

                  session.term.write(`\r\nError: ${msg.error}\r\n`);
                } else if (msg.type === 'debug') {
                  this.logDebug(msg.message || 'Debug', msg.data || {});
                }
              };

              ws.onclose = () => {
                this.logDebug('WebSocket closed', { sessionId });
                this.closeTerminal(sessionId);
              };

              const tile = document.createElement('div');
              tile.className = 'grid-stack-item';
              tile.dataset.sessionId = sessionId;
              tile.innerHTML = `
                <div class="grid-stack-item-content">
                  <div class="tile-header">
                    <div>
                      <div class="traffic-lights" aria-hidden="true">
                        <span class="close"></span>
                        <span class="min"></span>
                        <span class="max"></span>
                      </div>
                      <h4>${target.name}</h4>
                      <span>${target.ip || target.host} · ${target.type.toUpperCase()}</span>
                    </div>
                    <div class="tile-actions">
                      <button title="Focus" data-action="focus">
                        <span class="icon" aria-hidden="true">
                          <svg viewBox="0 0 24 24">
                            <path d="M7 3h10v2H7zM3 7h2v10H3zm16 0h2v10h-2zM7 19h10v2H7z" />
                          </svg>
                        </span>
                      </button>
                      <button title="Close" data-action="close">
                        <span class="icon" aria-hidden="true">
                          <svg viewBox="0 0 24 24">
                            <path d="M6 6l12 12M18 6l-12 12" stroke="currentColor" stroke-width="2" fill="none" />
                          </svg>
                        </span>
                      </button>
                    </div>
                  </div>
                  <div class="terminal-surface" id="terminal-${sessionId}"></div>
                </div>
              `;

              this.grid.addWidget(tile, { w: layout?.w || 6, h: layout?.h || 4, minW: 3, minH: 2 });

              const liveTile = document.querySelector(`.grid-stack-item[data-session-id="${sessionId}"]`);
              const tileEl = liveTile || tile;

              tileEl.querySelector('[data-action="close"]').addEventListener('click', (event) => {
                event.stopPropagation();
                this.closeTerminal(sessionId);
              });

              tileEl.querySelector('[data-action="focus"]').addEventListener('click', (event) => {
                event.stopPropagation();
                this.focusSession(sessionId);
              });

              let terminalEl = tileEl.querySelector(`#terminal-${sessionId}`);
              if (!terminalEl) {
                terminalEl = document.createElement('div');
                terminalEl.className = 'terminal-surface';
                terminalEl.id = `terminal-${sessionId}`;
                tileEl.querySelector('.grid-stack-item-content')?.appendChild(terminalEl);
              }

              let term;
              let fitAddon;
              try {
                if (!window.Terminal) {
                  throw new Error('xterm.js failed to load');
                }
                term = new window.Terminal({
                  cursorBlink: true,
                  fontFamily: 'Monaco, Menlo, Ubuntu Mono, monospace',
                  theme: {
                    background: '#000000',
                    foreground: '#f5f5f7',
                    cursor: '#64d2ff',
                  },
                });

                fitAddon = new window.FitAddon.FitAddon();
                term.loadAddon(fitAddon);
                term.open(terminalEl);
                fitAddon.fit();
              } catch (error) {
                console.error('Failed to create terminal:', error);
                const errorMessage = error?.message || 'Unknown error';
                this.toast(`Terminal failed to initialize: ${errorMessage}`);
                this.logDebug('Terminal init failed', { sessionId, error: errorMessage });
                ws.close();
                this.grid.removeWidget(tileEl);
                return;
              }

              const sendResize = () => {
                if (ws.readyState === WebSocket.OPEN) {
                  ws.send(
                    JSON.stringify({
                      type: 'resize',
                      sessionId,
                      cols: term.cols,
                      rows: term.rows,
                    })
                  );
                }
              };

              sendResize();

              let observer = null;
              if (typeof ResizeObserver !== 'undefined') {
                observer = new ResizeObserver(() => {
                  fitAddon.fit();
                  sendResize();
                });
                observer.observe(terminalEl);
              }

              term.onData((data) => {
                ws.send(
                  JSON.stringify({
                    type: 'input',
                    sessionId,
                    data,
                  })
                );
              });

              this.terminals.set(sessionId, {
                ws,
                term,
                fitAddon,
                tile: tileEl,
                target,
                observer,
              });

              this.authByTarget.set(target.id, authState);

              this.addSessionTab(sessionId, target);
              this.hideEmptyState();
              this.updateSummary();
            }

            addSessionTab(sessionId, target) {
              const tab = document.createElement('div');
              tab.className = 'session-tab';
              tab.dataset.sessionId = sessionId;
              tab.innerHTML = `
                <span>${target.name}</span>
                <span class="close">×</span>
              `;

              tab.addEventListener('click', (event) => {
                if (event.target.classList.contains('close')) {
                  this.closeTerminal(sessionId);
                  return;
                }
                this.focusSession(sessionId);
              });

              document.getElementById('sessionBar').appendChild(tab);
            }

            focusSession(sessionId) {
              if (this.activeSessionId && this.terminals.has(this.activeSessionId)) {
                this.terminals.get(this.activeSessionId).tile.classList.remove('tile-active');
                const oldTab = document.querySelector(`.session-tab[data-session-id="${this.activeSessionId}"]`);
                oldTab?.classList.remove('active');
              }

              this.activeSessionId = sessionId;
              const session = this.terminals.get(sessionId);
              if (!session) return;

              session.tile.classList.add('tile-active');
              const tab = document.querySelector(`.session-tab[data-session-id="${sessionId}"]`);
              tab?.classList.add('active');
              session.tile.scrollIntoView({ behavior: 'smooth', block: 'center' });
              session.fitAddon.fit();
            }

            closeTerminal(sessionId) {
              const session = this.terminals.get(sessionId);
              if (!session) return;

              if (session.ws && session.ws.readyState === WebSocket.OPEN) {
                session.ws.send(JSON.stringify({ type: 'close', sessionId }));
                session.ws.close();
              }

              session.observer?.disconnect();
              session.term.dispose();
              this.grid.removeWidget(session.tile);
              this.terminals.delete(sessionId);

              const tab = document.querySelector(`.session-tab[data-session-id="${sessionId}"]`);
              tab?.remove();

              if (this.activeSessionId === sessionId) {
                const remaining = this.terminals.keys().next().value;
                if (remaining) {
                  this.focusSession(remaining);
                } else {
                  this.activeSessionId = null;
                  this.showEmptyState();
                }
              }

              this.updateSummary();
            }

            showEmptyState() {
              document.getElementById('emptyState').style.display = 'block';
            }

            hideEmptyState() {
              document.getElementById('emptyState').style.display = 'none';
            }

            toast(message) {
              const toast = document.getElementById('toast');
              toast.textContent = message;
              toast.classList.add('show');
              setTimeout(() => toast.classList.remove('show'), 2000);
            }
          }

          const app = new TerminalApp();
        </script>
      </body>
    </html>
            hideEmptyState() {
              document.getElementById('emptyState').style.display = 'none';
            }

            toast(message) {
              const toast = document.getElementById('toast');
              toast.textContent = message;
              toast.classList.add('show');
              setTimeout(() => toast.classList.remove('show'), 2000);
            }
          }

          const app = new TerminalApp();
        </script>
      </body>
    </html>
